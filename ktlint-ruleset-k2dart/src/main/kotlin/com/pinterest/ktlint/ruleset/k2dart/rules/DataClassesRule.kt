package com.pinterest.ktlint.ruleset.k2dart.rules

import com.pinterest.ktlint.ruleset.k2dart.k2dartRulesetId
import com.pinterest.ktlint.core.Rule
import com.pinterest.ktlint.core.ast.ElementType
import com.pinterest.ktlint.core.ast.iz
import com.pinterest.ktlint.core.ast.izNot
import com.pinterest.ktlint.core.ast.nextSibling
import com.pinterest.ktlint.ruleset.k2dart.utils.*
import com.pinterest.ktlint.ruleset.k2dart.utils.addChildNewlineAfter
import com.pinterest.ktlint.ruleset.k2dart.utils.extractFieldNamesFromValueParameters
import com.pinterest.ktlint.ruleset.k2dart.utils.findFirstChildInsideClassBody
import com.pinterest.ktlint.ruleset.k2dart.utils.parseValueParameters
import org.jetbrains.kotlin.com.intellij.lang.ASTNode
import org.jetbrains.kotlin.com.intellij.psi.impl.source.tree.*

// generate data class autogenerated method
public class DataClassesRule : Rule("$k2dartRulesetId:$ruleName") {
    public companion object {
        public const val ruleName: String = "data-classes"
    }

    override fun beforeVisitChildNodes(
        node: ASTNode,
        autoCorrect: Boolean,
        emit: (offset: Int, errorMessage: String, canBeAutoCorrected: Boolean) -> Unit,
    ) {
        // - create a list of all fields defined in primary constructor
        // generate equals/ hashcode/ copywith methods with dartcode elementype
        if (node izNot ElementType.DATA_KEYWORD) return
        val modlistNode = node.treeParent
        //remove the "data" modifier
        modlistNode.removeChild(node)
        val classNode = modlistNode.treeParent
        //add /* data */ before class modifiers
        classNode.addChild(PsiCommentImpl(ElementType.BLOCK_COMMENT, "/* data */"), modlistNode)

        //todo //if no primary constructor, currently I don't know how to handle it, so return
        val primaryConstrNode = classNode.findChildByType(ElementType.PRIMARY_CONSTRUCTOR) ?: return

        //now parse the list of fields of the data class
        val extractedParams = parseValueParameters(primaryConstrNode)

        //             ~.psi.KtParameter (VALUE_PARAMETER)
        //               ~.c.i.p.impl.source.tree.LeafPsiElement (VAR_KEYWORD) "var"
        //               ~.c.i.p.impl.source.tree.PsiWhiteSpaceImpl (WHITE_SPACE) " "
        //               ~.c.i.p.impl.source.tree.LeafPsiElement (IDENTIFIER) "d"
        //               ~.c.i.p.impl.source.tree.LeafPsiElement (COLON) ":"
        //               ~.psi.KtTypeReference (TYPE_REFERENCE)
        //                 ~.psi.KtUserType (USER_TYPE)
        //                   ~.psi.KtNameReferenceExpression (REFERENCE_EXPRESSION)
        //                     ~.c.i.p.impl.source.tree.LeafPsiElement (IDENTIFIER) "Double"
        val fieldNames = extractFieldNamesFromValueParameters(extractedParams) ?: return

        val fields = extractedParams?.filter { it.findChildByType(valvarTokenSet)!=null } ?: return

        //now check if we have a class body
        //we should always have one thanks to the MissingClassBodyRule
        val classBodyNode = primaryConstrNode.nextSibling { it iz ElementType.CLASS_BODY } ?: return
        val className=classBodyNode.getEnclosingClassName() ?: return
        val classBodyNodeFirstChildInside = findFirstChildInsideClassBody(classBodyNode)
        var prev = classBodyNodeFirstChildInside
        //now generate methods inside class body
        //----generate copyWith method
        prev = classBodyNode.addChildNewlineAfter(prev)
        prev = classBodyNode.addChildAfter(
            LeafPsiElement(
                ElementType.DART_CODE,
                createCopyWithMethodText(className,fields,fieldNames),
            ),
            prev,
        )
        prev = classBodyNode.addChildNewlineAfter(prev)
        //----generate copyWith method
        prev = classBodyNode.addChildNewlineAfter(prev)
        prev = classBodyNode.addChildAfter(
            LeafPsiElement(ElementType.DART_CODE, createEqualsMethodText(className,fieldNames)),
            prev,
        )
        prev = classBodyNode.addChildNewlineAfter(prev)
        //----generate hashCode method
        prev = classBodyNode.addChildNewlineAfter(prev)
        prev = classBodyNode.addChildAfter(
            LeafPsiElement(ElementType.DART_CODE, createHashCodeMethodText(fieldNames)),
            prev,
        )
        prev = classBodyNode.addChildNewlineAfter(prev)
    }

    //             ~.psi.KtParameter (VALUE_PARAMETER)
    //               ~.c.i.p.impl.source.tree.LeafPsiElement (VAR_KEYWORD) "var"
    //               ~.c.i.p.impl.source.tree.PsiWhiteSpaceImpl (WHITE_SPACE) " "
    //               ~.c.i.p.impl.source.tree.LeafPsiElement (IDENTIFIER) "d"
    //               ~.c.i.p.impl.source.tree.LeafPsiElement (COLON) ":"
    //               ~.psi.KtTypeReference (TYPE_REFERENCE)
    //                 ~.psi.KtUserType (USER_TYPE)
    //                   ~.psi.KtNameReferenceExpression (REFERENCE_EXPRESSION)
    //                     ~.c.i.p.impl.source.tree.LeafPsiElement (IDENTIFIER) "Double"
    private fun dartParamDeclStringFromValueParameter(p: ASTNode, addNullable: Boolean): String? {
        val identifierNode = p.findChildByType(ElementType.IDENTIFIER) ?: return null
        val typeRefNode = p.findChildByType(ElementType.TYPE_REFERENCE) ?: return null
        var typeStr = typeRefNode.text
        if (addNullable) {
            if (!typeStr.endsWith("?")) typeStr += "?"
        }
        return "$typeStr ${identifierNode.text}"
    }

    //    AClass copyWith({
    //    String? field1,
    //    String? field2,
    //  }) {
    //    return AClass(
    //      field1: field1 ?? this.field1,
    //      field2: field2 ?? this.field2,
    //    );
    //  }
    private fun createCopyWithMethodText(className:String, fieldsNodes: List<ASTNode>?,fieldNames:List<String>): String? {
        if(fieldsNodes==null) return  null
        var res = "$className copyWith({\n"
        for( fn in fieldsNodes) {
            res += "   ${dartParamDeclStringFromValueParameter(fn,true)},\n"
        }
        res +="}) {\n"
        res +="  return $className(\n"
        for( n in fieldNames) {
            res+="    $n: $n ?? this.$n,\n"
        }
        res +="  );\n}"
        return res
    }

    //  @override
    //  bool operator ==(Object other) =>
    //      identical(this, other) ||
    //      other is ClosedTimeRange &&
    //          runtimeType == other.runtimeType &&
    //          s == other.s &&
    //          e == other.e;
    private fun createEqualsMethodText(className:String,fieldNames: List<String>): String {
        var res ="// AUTOGENERATED METHOD\n"
        res +="//TODO for maps substitute <field>==other.<field> with mapEquals(<field>,other.<field>\n"
        res +="//TODO for lists substitute <field>==other.<field> with listEquals(<field>,other.<field>\n"
        res += "@override\nbool operator ==(Object other) =>\n"
        res +="     identical(this, other) ||\n"
        res +="     other is $className &&\n"
        res +="     runtimeType == other.runtimeType &&\n"
        for (i in 0 until fieldNames.size - 1) {
            res += "     ${fieldNames[i]} == other.${fieldNames[i]} &&\n"
        }
        //explicitely add semicolon: this will be a dart node
        val last=fieldNames.last()
        res += "     $last == other.$last;"
        return res
    }

    // @override
    //  int get hashCode => s.hashCode ^ e.hashCode;
    private fun createHashCodeMethodText(fieldNames: List<String>): String {
        var res = "@override\nint get hashCode => "
        for (i in 0 until fieldNames.size - 1) {
            res += "${fieldNames[i]}.hashCode ^ "
        }
        //explicitely add semicolon: this will be a dart node
        res += "${fieldNames.last()}.hashCode;"
        return res
    }

}
